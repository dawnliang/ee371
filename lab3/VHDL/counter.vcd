$date
	Wed Nov  9 14:03:06 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module clock_divider $end
$var wire 1 ! clk $end
$var wire 32 " divided_clocks [31:0] $end
$var reg 32 # clocks [31:0] $end
$upscope $end
$scope module counter_testbench $end
$var wire 4 $ val [3:0] $end
$var reg 1 % clk $end
$var reg 1 & down $end
$var reg 1 ' reset $end
$var reg 1 ( up $end
$scope module dut $end
$var wire 1 % clk $end
$var wire 1 & down $end
$var wire 1 ' reset $end
$var wire 1 ( up $end
$var wire 4 ) val [3:0] $end
$var reg 4 * ns [3:0] $end
$var reg 4 + ps [3:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx +
bx *
bx )
x(
1'
x&
0%
bx $
b0 #
b0 "
z!
$end
#5
b0 *
b0 $
b0 )
b0 +
1%
#10
0%
#15
0&
0(
0'
1%
#20
0%
#25
1%
#30
0%
#35
1%
#40
0%
#45
b1 *
1(
1%
#50
0%
#55
b10 *
b1 $
b1 )
b1 +
1%
#60
0%
#65
b11 *
b10 $
b10 )
b10 +
1%
#70
0%
#75
b100 *
b11 $
b11 )
b11 +
1%
#80
0%
#85
b101 *
b100 $
b100 )
b100 +
1%
#90
0%
#95
b110 *
b101 $
b101 )
b101 +
1%
#100
0%
#105
b111 *
b110 $
b110 )
b110 +
1%
#110
0%
#115
b1000 *
b111 $
b111 )
b111 +
1%
#120
0%
#125
b1001 *
b1000 $
b1000 )
b1000 +
1%
#130
0%
#135
b1010 *
b1001 $
b1001 )
b1001 +
1%
#140
0%
#145
b1010 $
b1010 )
b1010 +
1%
#150
0%
#155
1%
#160
0%
#165
1%
#170
0%
#175
1&
1%
#180
0%
#185
b1001 *
0(
1%
#190
0%
#195
b1000 *
b1001 $
b1001 )
b1001 +
1%
#200
0%
#205
b111 *
b1000 $
b1000 )
b1000 +
1%
#210
0%
#215
b110 *
b111 $
b111 )
b111 +
1%
#220
0%
#225
b101 *
b110 $
b110 )
b110 +
1%
#230
0%
#235
b100 *
b101 $
b101 )
b101 +
1%
#240
0%
#245
b11 *
b100 $
b100 )
b100 +
1%
#250
0%
#255
b10 *
b11 $
b11 )
b11 +
1%
#260
0%
#265
b1 *
b10 $
b10 )
b10 +
1%
#270
0%
#275
b0 *
b1 $
b1 )
b1 +
1%
#280
0%
#285
b0 $
b0 )
b0 +
1%
#290
0%
#295
1%
#300
0%
#305
0&
1%
#310
0%
#315
1%
#320
0%
#325
1%
